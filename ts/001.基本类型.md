# TS中的基本类型

## 使用方式
:类型声明 —— 与强类型语言中的类型声明用法相同

## 数组声明
```ts
let arr1: number[] = [1, 2, 3];
let arr2: Array<number> = [1, 2, 3];
let arr3: Array<number | string> = [1, 2, 3, '1'];  // 联合类型 '|'
```

## 元组
定义了数组的长度和元素的类型
```ts
let tup1: [number, string] = [1, 'a'];
```

## `never`类型
表示永远不会有返回值的类型
```ts
let error = () => {
    throw new Error('error');
}

let endless = () => {
    while (true) {}
}
```

## 枚举类型

一组有名字的常量集合

1. 初始化无数字赋值的`enum`类型数据时，每个变量值从0开始依次递增，存在数字赋值时，根据赋值数字依次递增;
```ts
enum Role {
    Reporter = 1,
    Developer,
    Maintainer
}
```
`note`: 实现原理：通过`JS`反向映射的方式实现：
```js
var Role;
(function (Role) {
    Role[Role["Reporter"] = 1] = "Reporter";
    Role[Role["Developer"] = 2] = "Developer";
    Role[Role["Maintainer"] = 3] = "Maintainer";
})(Role || (Role = {}));
```

2. 字符串枚举
```ts
enum Message {
    Success = "成功了",
    Fail = "失败了"
}
```
`note`: 这里的实现就不再有反向映射，仅有对应枚举名称作为`key`的赋值

```js
var Message;
(function (Message) {
    Message["Success"] = "\u6210\u529F\u4E86";
    Message["Fail"] = "\u5931\u8D25\u4E86";
})(Message || (Message = {}));
```

3. 两种不同类型枚举成员的编译（常量型 & 计算型）

常量型在编译时即被赋值，计算型需要在实际运行时才会有值
```ts
enum Char {
    // 常量
    a,
    b = Char.a,
    c = 1 + 2,

    // 计算类型
    d = Math.random(),
    e = '123'.length
}
```
`note`: 计算类型之后再增加`enum`值，需要为新增的值赋值，否则会报错

4. 常量枚举

在编译阶段会被移除
```ts
const enum Month {
    Jan,
    Feb,
    Mar
}
```

**注意**： 不同枚举类型（包括枚举成员不同）的值是不能进行比较的

## 类型接口

### 函数类型接口
以下三种方式是等价的：
1. :function type
```ts
let add: (x: number, y: number) => number;
```
2. interface定义类型
```ts
interface Add {
    (x: number, y: number): number;
}
```
3. type定义类型
```ts
type Add = (x: number, y: number) => number;
```

## 类的继承与成员修饰符
类成员的属性都是实例属性，而不是原型属性，类成员的方法都是原型方法

### 成员修饰符
- `public`: 默认，对所有人都可见
- `private`: 子类，实例不可调用
- `protected`: 子类 & 自己可访问，实例中不可调用
- `readonly`: 定义的数据只读，必须有初始值，不可再被改变
- `contructor参数中使用public`: 定义的参数直接作为类的实例属性
- `static`: 直接通过类名调用

## 抽象类
`abstract`可用于修饰类，也可用于修饰函数
- 修饰类：类不能实例化，只可用于其他类继承`abstract`类
- 修饰函数：函数必须由子类进行实现

## 泛型

## 交叉类型
通过`&`符连接，取所有类型的并集

## 联合类型
通过`|`符连接，取所有类型的交集

## 索引类型
`keyof T`，获取`T`对象中所有`key`组成的联合类型

## 映射类型
- `Readonly<Obj>`: 将`Obj`中所有属性均设置为只读属性
- `Partial<Obj>`: `Obj`中所有属性均设置为可选属性
- `Pick<Obj>`: `Obj`中选择部分属性作为联合属性

## 条件类型
`T extends U ? X : Y`